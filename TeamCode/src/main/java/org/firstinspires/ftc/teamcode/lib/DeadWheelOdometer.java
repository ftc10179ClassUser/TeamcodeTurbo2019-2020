package org.firstinspires.ftc.teamcode.lib;

import com.qualcomm.robotcore.hardware.DcMotor;

import org.firstinspires.ftc.teamcode.lib.util.data.PVector;
import org.firstinspires.ftc.teamcode.lib.util.states.State;

public class DeadWheelOdometer {
    private Configurator config;
    public DcMotor leftOdometer;
    public DcMotor rightOdometer;
    public DcMotor centerOdometer;
    private PVector robotPos;
    private double robotRot;

    //Utility to find how much encoders have changed
    private double oldLeftEncoder = -1;
    private double oldRightEncoder = -1;
    private double oldCenterEncoder = -1;

    //Configure these to our wheels and wheelbase, measure in centimeters
    private PVector leftWheelPos = new PVector(-7.0, 4.0);
    private PVector centerWheelPos = new PVector(0.0, -6.0);
    private PVector rightWheelPos = new PVector(7.0, 4.0);
    double wheelRadius = 3;
    double strafeEfficiency = 1.0;
    double forwardEfficiency = 1.0;

    //Configure this to our motors
    double ticksToDegrees = 360.0/8192.0;

    //Autogenerated values
    double wheelCircumference = wheelRadius * 2.0 * Math.PI;
    double turnCircumference = Math.abs(rightWheelPos.x - leftWheelPos.x) * Math.PI;
    double centerCircumference = Math.abs(centerWheelPos.y - ((rightWheelPos.y + leftWheelPos.y)/2)) * 2.0 * Math.PI;

    private void odometryLoop() {
        if (config.getDebugMode()) {
            config.telemetry.addData("leftOdometer", -leftOdometer.getCurrentPosition());
            config.telemetry.addData("centerOdometer", -centerOdometer.getCurrentPosition());
            config.telemetry.addData("rightOdomenter", -rightOdometer.getCurrentPosition());
        }

        double leftDistChange = (((-leftOdometer.getCurrentPosition() - oldLeftEncoder) * ticksToDegrees) / 360) * wheelCircumference;
        double rightDistChange = (((-rightOdometer.getCurrentPosition() - oldRightEncoder) * ticksToDegrees) / 360) * wheelCircumference;
        double centerDistChange = (((-centerOdometer.getCurrentPosition() - oldCenterEncoder) * ticksToDegrees) / 360) * wheelCircumference;

        double localRobotRot = (((leftDistChange - rightDistChange) / 2.0) / turnCircumference);

        PVector localRobotPos;
        localRobotPos = new PVector(
                centerDistChange - ((localRobotRot / 360.0) * centerCircumference),
                (leftDistChange + rightDistChange) / 2.0
        );

        if (config.getDebugMode()) {
            config.telemetry.addLine("LocalPos: (" + Math.round(localRobotPos.x * 100) / 100 + ", " + Math.round(localRobotPos.y * 100) / 100 + ")");
            config.telemetry.addLine("LocalRot: " + Math.round(localRobotRot * 100) / 100);
        }

        //Clip rotation
        double addedRotation = robotRot - localRobotRot;
        double posClippedRotation = addedRotation > 360.0 ? addedRotation - 360.0 : addedRotation;
        double clippedRotation = posClippedRotation < 0.0 ? posClippedRotation + 360.0 : posClippedRotation;
        //add how the robot has rotated to it's overall rotation
        setRot(clippedRotation);

        //Convert to "field" coordinates
        localRobotPos = new PVector(localRobotPos.x * strafeEfficiency, localRobotPos.y * forwardEfficiency);
        PVector rotated = localRobotPos.rotate(Math.toRadians(robotRot));
        //Add how the robot has moved to it's overall position
        setPos(PVector.add(robotPos, rotated));

        //Update all of the "old" values
        oldLeftEncoder = -leftOdometer.getCurrentPosition();
        oldRightEncoder = -rightOdometer.getCurrentPosition();
        oldCenterEncoder = -centerOdometer.getCurrentPosition();
    }
    
    public DeadWheelOdometer(Configurator config) { //Store the config
        this.config = config;
    }

    public void beginOdometry() {
        //Get all of the motors from our config
        leftOdometer = config.getDcMotor("leftOdometer");
        rightOdometer = config.getDcMotor("rightOdometer");
        centerOdometer = config.getDcMotor("centerOdometer");

        //Update all of the "old" values
        oldLeftEncoder = -leftOdometer.getCurrentPosition();
        oldRightEncoder = -rightOdometer.getCurrentPosition();
        oldCenterEncoder = -centerOdometer.getCurrentPosition();

        //Add a state to run odometry functions every tick
        State odometryState = new State(() -> {
            //Run both odometry loops
            odometryLoop();

            //Telemetry
            if (config.getDebugMode()) {
                config.telemetry.addLine("Pos: (" + Math.round(robotPos.x*100)/100 + ", " + Math.round(robotPos.y*100)/100 + ")");
                config.telemetry.addLine("Rot: " + Math.round(robotRot*100)/100);
            }
            return false;
        }, () -> {}, "Odometry");

        config.stateMachine.addState(odometryState);
    }

    public PVector getPos() {
        return robotPos;
    }

    public double getRot() {
        return robotRot;
    }

    public void setPos(PVector pos) {
        robotPos = pos;
    }

    public void setRot(double rot) {
        robotRot = rot;
    }
}
